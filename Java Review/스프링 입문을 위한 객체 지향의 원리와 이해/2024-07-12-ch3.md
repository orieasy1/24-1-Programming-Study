# 03. 자바와 객체지향
## 객체 지향은 인간 지향이다.
절차적 구조적 프로그래밍에서 가장 중요한 것은 함수였다.
함수는 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 것이다.
복잡한 문제를 작은 문제로 분할, 즉 논리적인 단위로 블록화해서 작성하자는 것이다.
이런 논리적 단위의 블록을 **함수**라고 한다.
<br>

함수로 인해 프로그래밍이 조금 더 편해지고 나서 파격적인 제안이 나왔는데 그것이 바로 **객체지향**이다.
객체는 영어로 Object로 우리가 주변에서 사물을 인지하는 방식대로 프로그래밍 할 수 있지 않을까하는 것이 객체 지향의 출발이다.
현실세계를 인지하는 방식으로 프로그램을 만들자는 것으로 직관적인 것이 특징이다.
<br>

객체 즉 사물의 특징에 대해 생각해보자.
각각의 사물은 고유하고, 속성을 가지며, 특정한 행위를 한다.
프로그래밍에 객체도 똑같은 특징을 가진다.
그리고 사물을 하나하나 이해하기 보다는 사물을 분류(class)해서 이해하는 것이 인간의 인지법이다.
김원중, 윤동희, 나승엽이라고 하는 각각의 객체는 사람이라는 분류에 속한다.
그리고 사람이라는 분류안에 객체들은 나이, 몸무게, 키 등의 속성(property)을 가진다.
그리고 먹다, 자다, 움직인다 등의 특정한 행위(method)를 가지고 있다.
이를 다음과 같이 표기할 수 있다.
<br>

<table>
  <tr>
    <td>
      <table border="1">
        <tr>
          <th>Class명</th>
          <th>사람</th>
        </tr>
        <tr>
          <td>속성들</td>
          <td>나이<br>몸무게<br>키</td>
        </tr>
        <tr>
          <td>행위들</td>
          <td>먹다<br>자다<br>움직이다</td>
        </tr>
      </table>
    </td>
    <td>
      <table border="1">
        <tr>
          <th>윤동희: 사람</th>
          <th>객체명</th>
        </tr>
        <tr>
          <td>22세<br>85kg<br>187cm</td>
          <td>속성들</td>
        </tr>
        <tr>
          <td>먹다<br>자다<br>움직이다</td>
          <td>행위들</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

**UML 표기법**을 사용하여 위와 같이 표기할 수 있다.
UML이란 Unified Modeling Language의 약자로 통합 모델링 언어라는 뜻이다.
객체 지향 표기법의 조합이라고 생각해도 좋다.
복잡한 소프트웨어 시스템의 아키텍처, 디자인 및 구현을 위해 사용하는 언어이다.
객체 지향 소프트웨어를 개발할 때 시스템과 산출물을 명세화, 시각화, 문서화할 때 사용한다.
클래스명, 데이터, 메소드 순으로 작성하면 된다. (위 표 참고)

<br>

## 객체 지향의 4대 특성
객체 지향의 4대 특성은 캠슐화, 상속, 추상화, 다형성이다.

* 캡슐화(Encapsulation) + 정보 은닉(information hiding)
* 상속(Interitance) + 재사용
* 추상화(Abstraction) + 모델링
* 다형성(polymorphism) + 사용 편의


## 추상화: 모델링
일반인에게 추상화의 대가가 누구인지 물어본다면 아마도 피카소라고 이야기할 것이다.

![image](https://github.com/user-attachments/assets/d2ce4296-7799-40f8-833d-e87d804bb38e)

피카소는 눈에 보이는 그대로의 사물(객체)을 그리기 보다는 마음 속에 느껴지는 사물의 특징을 그렸다.
이집트 벽화도 마찬가지이다.
이들은 실제 못브이 아닌 추상적인 모습을 그려서 해당의 객체의 특징ㅇ르 더욱 정확하게 묘사하려 했다.
<br>

이처럼 추상화에서 중요한 것은 **공통 특성을 추출하는 것**이다.
추상화란 구체적인 것을 분해해서 관찰자가 관심있는 특성만 가지고 재조합하는 것이다.
**객체지향의 추상화는 곧 모델링이다**라는 관점을 기억하자.
<br>

객체 지향의 4대 특성(캡슐화, 상속, 추상화 다형성)은 클래스를 통해, 객체를 통해 구현된다.
* 객체는 유일무이한 사물이다.
* 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념이다.

세상에 존쟇나는 유일무이한 객체를 특성(속성과 기능)에 따라 분류해보니 객체를 통칭할 수 있는 집학점 개념, 클래스가 나오게 된 것이다.
즉 클래스는 분류일뿐 중요한 것은 객체이다.
<br>

클래스를 이용해 object(객체)를 만들었을 때는 object라는 표현보다는 instance라는 표현을 사용한다.

**객체 = 클래스의 인스턴스**

클래스를 객체의 설계도라고, 클래스는 붕어빵틀이고 객체는 붕어빵이라고 설명하는 것은 이 관점에서 나왔다.
클래스는 속성과 기능(또는 행위)를 가진다.
명사로 표현되는 특성을 속성, 동사로 표현된느 특성을 기능이라고 하며 기능은 수행 절차 또는 로직을 가진다.
<br>

여기서 내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?라는 질문을 던져야한다.
이어 따라서 클래스의 설계가 달라지기 때문이다.
이 관점에서 추상화를 다음과 같이 설명할 수 있다.
**추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 대한 특성만을 가지고 재조합하는것.**
애플리케이션의 경계에 따라 클래스는 다음과 같이 바뀔 것이다.

![image](https://github.com/user-attachments/assets/bf64bd35-42a1-46e7-a5e2-d7b1e7a0719e)
<br>

추상화는 모델링이다.
모델은 실제 사물을 정확히 복제하는 것이 아니라 목적에 맞게 관심 잇는 특성만 추출해서 표현하는 것이다.
다르게 말하면 **모델은 추상화를 통해 실제 사물을 단순하게 묘사**하는 것이다.
이런 모델링(추상화)은 객체 짛야에서 클래스를 설계할 때 필요한 기법이고 데이터베이스의 테이블을 설계할 때 필요한 기법이다.
<br>

T메모리에는 3대 영역이 스태틱, 스택, 힙이 있다.
java.lang 패키지와 모든 클래스들은 T메모리의 static 영역에 배치된다.
또 객체를 참조할 수 있는 객체 참조변수는 스택 영역 중에서 main() 메서드 스택 프레임 안에 생성된다.
그러나 클래스를 바탕으로 만들어진 객체들은 힙 영역에 저장된다.
<br>

클래스 멤버들은 static 키워드와 함께 사용되고 static영역에 상주하게 되므로 정적 멤버라고한다.
static은 "고정된"이라는 뜻을 가지고 있는데 static영역에 올라간 정보는 main()메서드가 시작되기 전에 올라가서 종료된 후에 내려올 정도로 단단이 고정되어있다.

객체 멤버들은 객체가 클래스의 인스턴스이므로 인스턴스 멤버라고도 한다.
<br>

정적 속성(필드)은 해당 클래스의 모든 객체가 같은 값을 가질 때 많이 사용한다.
정적 메서드는 객체들의 존재 여부에 관계 없이 사용할 수 있는 메서드이다.
정적 멤버들은 객체가 아닌 클래스에 속해있으며 클래스는 JVM 구동시 T메모리의 static 영역에 바로 배치되기 때문에 객체의 존재 여부에 관계 없이 쓸 수 있다.
따라서 main()메서드는 무조건 정적 메서드로 선언되어야한다.
또 math 클래스의 메서드들과, 정적변수에 대한 getter setter 세터 메서드도 정적 메서드를 사용할 수 있을 것이다.
<br>

* 클래스 멤버 = 정적 멤버 = static 멤버
* 객체 멤버 = 인스턴스 멤버 = 오브젝트 멤버
* 필드 = 속성 = property

## 상속: 재사용 + 확장
객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필욯나 특성을 추가 즉 확정해서 사용할 수 있다는 의미이다.
<br>

상속은 반드시 **하위 클래스는 상위 클래스다.**라는 문장을 만족해야 한다.
* 포유류는 동물이다.
* 고래는 포유류다.
* 고래는 동물이다.
이렇게 말이다.
위 문장은 객체 지향 설계 5원칙 가운데 LSP(리스코프 치환 원칙)을 나타내는 말이다.
상속을 영어로는 inheritance라고 말하는데 이보다는 상속의 키워드인 **extends**의 의미로 이해하는 것이 더 정확하다.
<br>

동물 뽀로로 = new 펭귄();

위 문장은 펭귄을 낳고 동물 역할을 하는 뽀로로라 이름 지었다.가 맞는 해석이다.
<br>

상속은 is a 관계를 만족해야한다는 말이 있다.
예를 들자면 펭귄 is a 동물.
주어는 펭귄 하위클래스이고 보어는 동물 상위 클래스이다.
번역을 하면 하위 클래스는 하나의 상위 클래스가 된다.
이것보다는 is a kind of을 적용시킨 한 마리의 펭귄은 동물의 한 분류이다가 더 맞는 표현이다.
<br>

자바는 다중 상속을 지원하지 않는다.
대신 인터페이스를 도입해 다중 상속의 득은 취하고 실은 버렸다.
인터페이스는 **구현 클래스 is able to 인터페이스**의 관계를 나타탠다.
고래는 헤엄칠 수 있다와 같이 "무엇을 할 수 있는" 이라는 표현 형태로 만드는 것이 좋다.
<br>

상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페잇는 구현을 강제할 메서드의 개수가 작을 수록 좋다.
이는 각각 LSP(리스코프 치환 원칙)과 ISP(인터페이스 분할 원칙)에 기반한다.
<br>

상속과 인터페이스의 UML 표기법은 다음과 같다.

![image](https://github.com/user-attachments/assets/71bd2b07-d4db-41e2-a573-20111e86fbb8)


<br>

## 다형성: 사용편의성

객체 지향에서 다형성이라고 하면 오버라이딩(overriding)과 오버로딩(overloading)이라고 할 수 있다. (오버로딩이 다형성인지에 대해서는 이견이 있다.)
<br>

Overriding과 Overloading을 구분하기 위해서는 ride와 load에 주목해야한다.
* ride: 올라타다
* load: 적재하다
<br>

하늘위에서 본다고 가정했을 때 오토바이 위에 운전자가 올라탄다면 그 오토바이가 보일지, 트럭 위에 여러 짐을 나란히 적재했을 때 여러 개의 짐이 보일지를 생각해보면 이해하기 쉬울 것이다.

* Overriding: 같은 메서드 이름, 같은 인지 목적으로 상위 클래스의 메서드를 재정의하는 것
* Overloading: 같은 메서드 이름, 다른 인지 목적으로 다수의 메서드를 중복 정의하는 것

따라서 오버라이딩은 재정의의 개념이므로 상위 클래스의 메서드와 같은 메서드 이름과 같은 인자 리스트를 가져야하고, 오버로딩의 경우 중복 정의의 개념이므로 같은 메서드 이름을 가져야하지만 다른 인자 리스트를 가져도 된다.
<br>

Animal 클래스가 다음과 같을 때

```java
public class Animal {
    public String name;

    public void showName() {
        System.out.printf("안녕 나는 %s야. 반가워\n", name);
    }
}
```
<br>

Animal 클래스를 상속한 Penguin클래스에서 오버라이딩과 오버로딩은 다음과 같다.

```java
public class Penguin extends Animal {
    public String habitat;

    public void showHabitat() {
        System.out.println("%s는 %s에 살아\n", name, habitat);
    }

    //오버라이딩 - 재정의
    public void showName() {
        System.out.println("내이름 알아서 뭐하게");
    }

    //오버로딩 - 중복정의
    public void showName(String yourName) {
        System.out.println("%s아 안녕, 나는 %s라고해\n", yourName, name);
    } 
}
```
<br>

만약 아래 Driver 클래스를 실행한다면 주석 처리된 것 처럼 출력 될 것이다.

```java
public class Driver {
    public static void main(String[] args) {
        Penguin pororo = new Penguin();

        pororo.name = "뽀로로";
        pororo.habitat = "남극";

        pororo.showName();  // Penguin 객체에 의해 Animal 객체 메서드가 가려졌기 때문에 Penguin 객체에 정의된 메서드가 호출됨
        pororo.showName("짱구");    //문자열 하나를 인자로 받는 오버로딩된 메서드 호출
        pororo.showHabitat();

        Animal pingu = new Penguin();

        pingu.name = "핑구";
        pingu.showName();   //상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩된 메서드가 호출된다.
    }
}
```

<br>

## 캡슐화: 정보 은닉
자바에서 정보 은닉이라고 하면 접근제어자인 private, default, protected, public이 생각난다.

* public: 모두가 접근 가능
* protected: 상속, 같은 패키지 내의 클래스에서 접근가능
* default: 같은 패키지 내의 클래스에서 접근가능
* private: 본인만 접근 가능

이것들을 사용해서 캡슐화를 진행한다.
<br>

캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶는 것을 의미한다.
객체의 내부 상태를 외부로부터 보호하고 객체 간의 상호작용을 정의된 인터페이스를 통해서만 가능 하도록 보호하고 객체 간의 상호작용을 정의된 인터페이스를 통해서만 가능하게 한다.
<br>

캡슐화의 주요 특징은 다음과 같다.
1. 정보은닉: 외부에서 직접 접근하지 못하게 하고, 공개된 메서드를 통해서만 접근하도록한다.
2. 데이터 보호
3. 인터페이스 제공: 객체는 메서드를 통해서만 상호작용할 수 있으며 이 메서드들을 인터페이스라고 한다.