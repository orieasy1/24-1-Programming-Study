# Chapter6. 클래스

[아무것도 모르던 시절 정리해놓은 클래스에 대하여.txt](https://github.com/orieasy1/23-1-Programming-Study/blob/main/Java/2023-04-18-classninstance.md)

## 객체 지향 프로그래밍 (Object Oriented Programmingror)

객체지향 프로그래밍은 실세계에 존재하고 인지하고 있는 객체를 소프트웨어 세계에서 표현하기 위해 객체의 핵심적은 개념 똔느 기능만을 추출하는 추상화(abstraction)을 통해 모델링하려는 프로그래밍 패러다임을 말한다.

즉 우리가 실세계에서 사물을 인증하는 방식을 프로그래밍에 적목하는 것이다.
<br><br>
어떤 제품을 만들 때 부품을 먼저 만들고 이 부품을 하나씩 조립해서 완성품을 만들 듯이 소프트웨어를 개발할 때도 부품에 해당하는 객체들을 먼저 만들고 이 객체들을 하나씩 조립해서 완성된 프로그램을 제작하는 것이다. <br>

* 객체: 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 다른 것과 식별 가능한 것
    * 필드(속성)와 메소드(동작)로 구성됨
    * 클래스의 인스턴스: 클래스로 부터 생성된 실제 데이터
    * ex) 자동차 클래스 -> 소나타, 아반떼 등 객체 생성
* 클래스: 객체들을 생성하기 위한 템플릿, 객체를 생성하기 위한 추상적인 설계도(필드와 메서드로 구성)
    * 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.
* 필드: 객체의 상태를 나타내는 데이터
    * 클래스 내부에 선언
    * 객체마다 각각 다른 값을 가질 수 있음
    * ex) 자동차 클래스의 필드로는 속도, 색상, 모델들이 있을 것
* 메서드: 객체의 동작이나 행위를 나타내는 함수
    * 객체가 다른 객체들의 기능을 이용할때 메소드를 사용함(객체들 사이의 상호작용 수단)
    * 클래스 내부에서 선언되며, 객체의 상태를 변경하거나 특정한 작업을 수행
<br>

**객체지향 프로그래밍 개발 단계**

1. 클래스 설계
2. 설계된 클래스를 가지고 사용할 객체 생성
3. 생성된 객체를 이용
<br>

**객체 간의 관계**

객체들은 각각 독립적으로 존재하고 다른 객체와 서로 상호작용하면서 동작한다.
이때 객체들 사이의 상호작용 수단이 메소드인 것이다. 
객체는 단독으로 존재할 수 있지만 대부분 다른 객체와 관계를 맺고 있다.

* 집합관계: 전체와 부분의 관계
    * 한 객체가 다른 객체를 포함하며, 포함된 객체는 여러 객체에 속할 수 있음
    * ex) 도서관이 채긍ㄹ 포함하고 있으며, 책은 여러 도서관에 속할 수 있음
* 의존 관계: 한 객체가 다른 객체를 사용하는 관계
    * 클래스A의 메서드가 클래스B의 인스턴스를 생성하거나 메서드를 호출하는 경우
    * 자동차 클래스가 엔진 클래스의 인스턴스를 생성하여 사용하는 경우
    ```java
    class Engine {
        private int horsepower;

        public Engine(int horsepower) {
            this.horsepower = horsepower;
        }

        public void start() {
            System.out.println("Engine started");
        }
    }


    class Car {
        private String model;
        private Engine engine;

        public Car(String model) {
            this.model = model;
            // Car 클래스의 생성자에서 엔진 클래스의 인스턴스를 생성
            this.engine = new Engine(200);
        }

        public void startEngine() {
            // Car 클래스의 메서드에서 엔진 클래스의 메서드를 호출하여 엔진을 시작
            engine.start();
            System.out.println("Car started");
        }
    }

    public class Main {
        public static void main(String[] args) {
            // Car 객체 생성
            Car myCar = new Car("Hyundai");
            // Car 객체의 메서드 호출
            myCar.startEngine();
        }
    }
    ```
* 상속관계: 부모와 자식 관계
    * 하위 클래스가 상위클래스의 특성과 동작을 상속받는 관계
    * ex) 자동차가 기계의 특징(필드, 메소드)을 물려 받는 다면 기계(부모)와 자동차(자식)은 상속관계에 있다고 할 수 있다.
    * 부모클래스를 Super class, 자식 클래스를 Sub class라고 하기도 한다.
<br>

**객체지향 프로그래밍의 특징**

* 캡슐화: 객체의 필드와 메소드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
    * 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공되는 필드와 메소드만 이용할 수 있다.
    * 외부의 잘못된 사용으로 객체가 손상되지 않도록 보호하는 것
    * 접근제한자를 사용하여 캡슐화된 멤버를 노출 시킬 것인지 숨길 것인지를 결정
* 상속: 부모 객체가 자기가 가지고 있는 필드와 메소드를 자식객체에 물려주어 자식 객체가 사용할 수 있도록 하는 것.
    * 코드의 제사용성을 높임
    * 콛를 구조화하여서 유지보수 시간을 최소화 시켜줌
* 다형성: 같은 이름의 메서드가 다른 동작을 하는 것
    * 프로그램을 구성하는 객체를 바꾸어 프로그램의 실행 성능이 다르게 나오도록 함.
    * 한 메서드가 다양한 타입의 객체를 처리할 수 있으며, 이는 유연하고 확장가능한 코드를 작성하는데 도움을 준다.


## 6.2 객체와 클래스

앞에서 말했듯이 객체를 생성할 때는 설계도가 필요하다.
자바에서는 설계도가 바로 클래스이다.
클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.

**클래스로 부터 생성된 객체를 해당 클래스의 인스턴스(instance)라고 부른다.**

하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있는데 이것은 동이한 설꼐도로 여러 대의 자동차를 만드는 것과 동일하다.
<br><br>
객체를 생성하면 메모리의 힙(heap) 영역에 저장된다.
힙 영역은 프로그램 실행 중 동적으로 할당되는 메모리 공간으로 객체와 배열 등이 저장된다.

객체를 생성하면 이 영역에 객체의 크기에 맞게 필요한 메모리 공간을 할당한다.
할당된 메모리 공간에는 객체의 모든 필드가 초기값으로 설정된다.
기본적으로 정수형은 0, 실수형은 0.0, boolean 필드는 false, 객체 참조형 필드는 null로 초기화 된다.
객체의 초기화는 생성자를 통해 이루어진다. 생성자는 객체가 생성될 때 호출되는 특별한 메서드로 객체의 초기화 과정을 수행한다.
생성된 객체는 메모리에서의 주소를 갖는다.
이 주소는 개체의 실제 위치를 가리키며, 참조변수에 할당된다.
이렇게 생성된 객체를 가리키는 참조변수를 통해 객체에 접근하고 사용할 수 있다.
<br>

## 6.3 클래스 선언

```java
class 클래스명 {
    
}

pulbic class 클래스명{

}
```

class + 클래스명이 기본 구조이다.

밑에 방식에서는 class 앞에 public이라는 접근제한자를 작성해주었다.
이건은 공개 클래스를 선언한다는 것이다.
공캐 클래스란 어느 위치에 있든지 패키지와 상과넝ㅄ이 상요할 수 있는 클래스를 말한다.
public class가 있을 경우 소스파일의 이름은 반드시 public class의 이름과 일치해야한다.

추가로 하나의 소스파일에 여러 클래스를 선언할 수 도 있다.
<br><br>
클래스 내부에는 객체가 가져야할 구성 멤버가 선언된다.
구성 멤버에는 필드, 생성자, 메소드가 있다.

## 6.4 객체 생성과 클래스 변수

클래스로 부터 객체를 생성하려면 객체 생성 연산자인 **new**가 필요하다.
<br><br>
객체를 생성하면 힙영역에 객체의크기에 맞추어 메모리 공간을 할당하고 저장된다.
객체가 할동된 메모리의 주소가 결정되고 해당 주소는 객체를 가리키는 참조변수에 할당된다.
참조변수를 통해 객체에 접근하고 사용할 수 있다. (객체의 주소를 담는 참조변수가 생성되어야지만 해당 객체에 접근이 가능하다.)
<br><br>
그래서 객체를 생성할 때 코드는 다음과 같은 구조를 가진다.

```java
데이터타입 변수명 = new 클래스명();

ClassName obj = new ClassName();
```

즉 ClassName 클래스의 객체를 생성하여 ClassName 타입의 참조변수인 obj에 할당하겠다는 것으로 해석할 수 있다.
<br>

객체 생성 예시문

```java
class Student {

}

public class StudentExample {
    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println("s1 변수기 Student 객체를 참조");

       Student s2 = new Student();
        System.out.println("s2 변수가 Student 객체를 참조");
    }
} 
```

<br>
클래스의 용도는 크게 두가지로 나눌 수 있다.

* 라이브러리 클래스: 실행할 수 없으며 다른 클래스에서 이요하는 클래스(ex. Student Class)
* 실행클래스: main() 메소들르 가지고 있는 실행 가능한 클래스 (ex. StudentExample Class)
<br>

## 6.5 클래스의 구성멤버

```java
public class ClassName {
    //필드 선언: 객체의 데이터를 저장(클래스의 상태를 나타냄)
    int field name; //멤버 변수로 정의

    //생성자 선언: 객체 생성 시 초기화 역할 담당
    //리턴타입이 없고, 클래스 이름과 동일
    ClassName() {
        ...
    }

    //메소드: 객체의 동작으로 호출 시 실행하는 블록
    int methodName() {
        ...
    }
}
```
<br>

**메소드 관련 추가 정리**

메소드의 기본 선언 방식은 다음고 ㅏ같다.

```java
접근제한자 반환타입 메서드이름(매개변수 목록) {
    //메소드 실행 내용
    //내용에 따라 반환값 혹은 반환문 작성
}
```

* 접근제한자: 메서드가 접근 가능한 범위 지정
    * public: 어디서든 접근 가능
    * protected: 같은 패키지 내 또는 해당 클래스를 상속받은 클래스에서 접근 가능
    * private: 해당 클래스 내에서만 접근 가능
* 반환타입: 메서드 실행 후 반환하는 값의 데이터 타입 지정
    * 반환 값이 없을 경우: void 사용
* 매개변수 목록
    * 메서드가 실행될 떄 필요한 인자들을 선언
    * 매개변수 가 없는 경우 빈괄호 ()로 선언
    * 매개변수는 메서드 내에서 사용되는 지역변수, 메서드가 호출될 때 전달된 값에 의해 초기화 됨
<br>

## 6.6 필드의 선언과 사용

필드의 선언보단 필드와 다른 변수가 어떻게 다른지에 대해 설명해보려 함

* 지역 변수 Local Variable
    * 특정 블록 또는 메서드 내에서 선언되고 사용됨
    * 해당 블록 또는 메서드 내에서만 유효하며, 범위(scope)는 선언된 블록 내부로 제한 됨.
    * 메서드나 블록이 실행될때 생성되고 실행이 종료되면 소멸된다.
    * 사용하기 전에 반드시 초기화되어야함
* 멤버 변수(= Field필드)
    * 클래스 내에서 선언되고 사용
    * 해당 클래스의 모든 인스턴스(객체)에 속하며 객체의 상태를 나타냄
    * 객체가 생성될 때 생성되고 객체가 소멸될 때 함꼐 소멸함
    * 클래스의 모든 메서드에서 사용될 수 있음
    * 일반적으로 객체의 상태를 나타내며 객체마다 고유한 값을 가질 수 있음
* 정적 변수 Static Variable
    * 클래스의 인스턴스가 아닌 클래스 자체에 속하는 변수
    * 클래스 내에서 static 키워드를 사용하여 선언된다.
    * 모든 객체들이 공유하는 값이면 한 번만 생성되고 모든 객체가 이를 공유함
    * 프로그램이 시작될 때 생성되고, 프로그램이 종료될 때 소멸된다.
    * 주로 상수나 공통된 상태를 나타내는데 사용됨
* 매개변수 Parameter
    * 메서드나 함수에 전달되는 값을 받는 변수
    * 메서드나 함수를 호출할 때 전달되는 값(arugment)을 받아들이는 역할을 한다.
    * 메세드나 함수가 호출될 때 생성되고 메서드나 함수가 종료될 떄 소멸
<br>

### 필드 사용

필드를 사용한다는 것은 필드값을 일고 변경하는 것을 말한다.
클래스에서 필드를 선언했다고 해서 바로 사용할 수 있는 것은 아니다.
필드는 객체의 데이터 이므로 객체가 존재하지 않으면 필드도 존재하지 않는다.

클래스로부터 객체가 생성된 후에 필드를 사용할 수 있다.
필드는 객체 내부의 생성자와 메소드 내부에서 사용할 수 있고, 객체 외부에서도 접근해서 사용할 수 있다.

외부 객체에서는 참조변수와 도트(.) 연산자를 이용해서 필드를 읽고 변경할 수 있다.
도트(.)연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조변수 뒤에 붙인다.

```java
public class Car{
    //필드 선언
    String model;
    boolean start;
    int speed;

    Car() {
        speed = 60; //생성자에서 필드값 변경
    }

    void changeSpeed() {
        speed = 70; //객체 내부 메소드에서 필드값 변경
    }
}
```

```java
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car();

        myCar.speed = 80;   //객체 외부에서 필드값 변경
        System.out.println(myCar.speed);
        myCar.changeSpeed();
    }
}
```

클래스들을 이렇게 작성하고 run시켜주면 Car()생성자는 개체가 생성될 때 호출 되어 speed 필드를 60으로 쵝화 한다.
생성자는 객체가 생성될 때마다 자동ㅇ으로 호출되므로 Car 클래스의 객체가 생성될 때마다 speed 필드를 60으로 초기화 시킨다.
이후 객체 외부에서 myCar.speed를 사용하여 필드값을 80으로 변경한다.
그리고 Car 클래스의 changeSpeed() 메서드를 호출하여 speed로 변경하는 것이 위 코드에서 보이는 필드 사용이다.
<br

## 6.7 생성자 선언과 호출

[생성자가 어려워서 쫌쫌따리 정리해둔 기록.txt](https://github.com/orieasy1/23-1-Programming-Study/blob/main/Java/2023-04-18-constructor.md)

<br>
new 연산자는 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화하는 역할을 한다.
<br><br>
객체 초기화란: 필드 초기화를 하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것
<br><br>
new연산자에 의해 생성자가 성공적으로 호출되면 메모리의 heap 영역에 객체가 생성된다.
즉 생성자가 성공적으로 실행이 끝나면 new 연산자는 객체의 주소를 리턴한다.
리턴된 주소는 클래스 변수에 대입되어 객체의 필드나 메소드에 접근할 때 이용된다.
<br>

### 기본 생성자

자바의 클래스는 생성자가 반드시 존재해야하고 하나 이상을 가질 수 있다.
클래스를 만들 때 생성자 선언을 생략했다면 자바 컴파일러는 내용이 비어있는 기본 생성자를 자동으로 넣어줄 것이다.

기본 생성자의 형태는 다음과 같다.

```java
public class ConstructorExam {
    public ConstructorExam() {

    }
}
```

클래스가 public class로 선언되면 기본 생성자도 
그러나 개발자가 명시적으로 선언한 생성자가 있다면 컴파일러는 기본 생성자를 추가하지 않는다.
객체를 다양하게 초기화하기 위해서 개발자는 생성자를 명시적으로 선언한다.
<br>

### 생성자 선언

생성자의 이름은 클래스명과 갇고, 리턴타입이 없다.
따라서 다음과 같은 형태를 띈다.

```java
클래스명 (매개변수, ...) {
    객체 초기화 코드;
}
```

매개변수는 new연산자로 생성자를 호출할 때 매개값을 생성자 블록 내부로 전달하는 역할을 한다.

만약 Car class를 다음과 같이 작성해준다면

```java
public class Car{
    String company = "Hyundai";
    String model;
    String color;
    int maxSpeed;
    int speed;

    //생성자 선언
    Car(String model, String color, int maxSpeed) {
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}
```

개발자가 선언한 생성자에 맞추어 매개변수를 작성해줘야한다.

```java
public class CarExample {
    public static void main(String[] args) {
        // Car 객체 생성
        Car myCar = new Car("Grandeur", "black", 250, 60);
        //Car myCAr = new Car();    기본 생성자는 호출할 수 없다.

        // Car 객체 필드값 출력
        System.out.println("제작회사: " + myCar.company);
        System.out.println("모델명: " + myCar.model);
        System.out.println("색깔: " + myCar.color);
        System.out.println("최고속도: " + myCar.maxSpeed);
        System.out.println("현재속도: " + myCar.speed);

        // Car 객체의 필드값 변경
        myCar.speed = 80;
        System.out.println("수정된 속도: " + myCar.speed);
    }
}
```
<br>

생성자는 메서드와 형태가 유사하고 실제로 메서드의 일종이지만 반환타입이 없다는 것이 다른점이다.

### 필드 초기화

생성자의 핵심 기능은 필드 초기화이다.
즉 생성자를 사용하여 객체가 생성될 때 필드를 초기화를 할 수 있다.
필드 초기화는 객체의 상태를 설정하는데 중요한 역할을 한다.

객체마다 동일한 값을 갖고 있다면 필드 선언시 초기값을 대입하는 것이 좋고, 객체마다 다른 값을 가져야 한다면 생성자에서 필드를 초기화하는 것이 좋다.


## 6.9 ~ 10 인스턴스 멤버와 정적 멤버

필드와 메소드는 선언 방법에 따라 인스턴스 멤버와 정적 멤버로 분류할 수 있다.

* 인스턴스 멤버: 객체에 소속된 멤버, 객체를 생성 후 사용할 수 있음
* 정적 멤버: 클래스에 고정된 멤버, 객체 생성 없이도 사용할 수 있는 멤버

### 인스턴스 멤버 선언 및 사용

### 정적 멤버 선언
자바는 클래스 loader를 사용해서 클래스를 메소드 영역에 저장하고 사용한다.
메소드 영역에서는 .class 파일을 읽어들여 각각의 클래스별로 필드 데이터, 메소드 코드, 생성자 코드 등을 저장하는 영역이다.
힙 영역은 주로 객체와 배열의 인스턴스를 저장하며 메소드 영역은 클래스 관련 정보(구조, 정적 변수, 상수, 바이트 코드 등)를 저장한다.
<br><br>
정적(static) 멤버란 메소드 영역의 클래스에 고정적으로 위치하는 멤버를 말한다.
이들은 클래스가 메모리에 로드될 때 생성되어 프로그램이 종료될 때까지 남아있는다.
정적 멤버는 개체를 생성할 필요없이 클래스를 통해 바로 사용이 가능하다.
멤버 앞에 static 이라는 키워드를 추가해주면 된다.

```java
public class Calculator {
    String color;
    //정적 필드
    static double pi = 3.14158;

    //정적 메소드
    static int circumference(int r) {
        return 2 * pi * r;
    }

    static int area(int r) {
        return pi * r * r;
    }
}
```

객체마다 가지고 있을 필요성이 없는 공용적인 필드를 정적 필드로 선언하는 것이 좋다.
예를 들어서 원의 넓이나 둘레를 구할 때 필요한 파이 값의 경우 정적 필드로 선언하는 것이 좋을 것이다.

인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다.
정적 메소드 안에서는 인스턴스필드가 인스턴스 메소드를 사용할 수 없기 때문이다.
