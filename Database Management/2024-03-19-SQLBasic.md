# Database Management Week4

## SQL Basic

### The SFW query

**SQL queryë€?**

ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜ ì¡°ì‘í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ëª…ë ¹ì–´ë‚˜ ì§ˆì˜ë¥¼ ë§í•¨.
SQLì€ Structured Query Languageì˜ ì•½ìë¡œ RDBMSì—ì„œ ë°ì´í„°ë¥¼ ì €ì¥, ìˆ˜ì •, ê²€ìƒ‰ ë° ì‚­ì œí•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” í‘œì¤€ì–¸ì–´ì´ë‹¤.
DDL, DML, DCL ë“±ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.
<br>

**SFW query: SELECTë¬¸ìœ¼ë¡œ ë°ì´í„° ê²€ìƒ‰í•˜ê¸°**

SELECTë¬¸ì€ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë°ì´íŠ¸ë¥¼ ê²€ìƒ‰í•˜ëŠ” êµ¬ë¬¸ì´ë‹¤.
í˜•íƒœëŠ” ë‹¤ìŒê³¼ ê°™ì€ë°

```SQL
SELECT attributes
FROM oneOrMoreRelations
WHERE conditions
```

ì´ë¥¼ ì¤„ì—¬ì„œ SFW qureyë¼ê³ ë„ ë¶€ë¥¸ë‹¤.
<br><br>
We are interested in some attributes out of the entire attributes.
Subset of all the attributes defined in the relation.
We choose attribute by SELECT.
<br><br>
If there is one relation, we can find data only from the relation
If there is many tables, we can find data joinning from the multiple reations.
Since most of the time, there are a lot of tables in DB system, we hae to specify the table relation to find data.

We use FROM to specify the interested tables.
<br><br>
Specify conditions to choose tuples we use WHERE.
As I mentioned table has 2 dimensional space, attribute and tuple.
We need to choose attribute by SELECT close and we choose tuples by WHERE close.
<br><br>
It is the process to specify conditions to filter data in the relation.
ë’¤ì—ì„œ ì„¤ëª…í•  Selectionê³¼ Projection ëª¨ë‘ ë°ì´í„°ë² ì´ìŠ¤ì— í•„ìš”í•œ ì •ë³´ë¥¼ ì¶”ì¶œí•˜ê³  í•„í„°ë§í•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.
Selectioì€ í–‰ì„ ì„ íƒí•˜ê³  í•„í„°ë§í•˜ëŠ” ì‘ì—…ì´ë©°, Projectionì€ ì—´ì„ ì„ íƒí•˜ê±°ë‚˜ ì œê±°í•˜ëŠ” ì‘ì—…ì´ë‹¤.
<br>

**Simply SQL query: Selection**

Selection is the operation of filtering a relation's tuples on some condition.

Selectionì€ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í–‰(row)ë¥¼ ì„ íƒí•˜ëŠ” ì‘ì—…ì´ë‹¤.
ì¦‰ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í–‰ë§Œì„ ì¶”ì¶œí•˜ëŠ” ê²ƒì´ë‹¤.
ì´ëŠ” WHEREì ˆì„ ì‚¬ìš©í•˜ì—¬ ìˆ˜í–‰ëœë‹¤.

ì‚¬ì‹¤ SELECT ë¬¸ì˜ ê¸°ë³¸ í˜•ì‹ì€ SELECT ì—´ FROM í…Œì´ë¸”ì´ë‹¤. 
ì „ì²´ì—´ì„ ê²€ìƒ‰í•˜ë ¤ë©´ ì—´ ì´ë¦„ì„ ëª¨ë‘ ì…ë ¥í•˜ëŠ” ëŒ€ì‹  * ê¸°í˜¸ë¥¼ ì‚¬ìš©í•œë‹¤.

DB receives this SQL based on the table.
It will find the result by executing some operations.

```SQL
SELECT *
FROM Product
WHERE Category = 'Gadgets'
```

ë¼ê³  ì‘ì„±í•˜ë©´

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/2d0c867a-041e-4699-a112-4645d1ee800b)

ì—ì„œ Categoryê°€ Gadgetsì— í•´ë‹¹í•˜ëŠ” ë‹¤ìŒ ë‘ productë§Œ í‘œì‹œëœë‹¤.
Upper query means find products which category is Gadgets from product table.

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/e413b901-b7e3-40a6-9032-60813b683bfb)
<br>

**Simple SQL Query: Projection**

Projection is the operation of producing an output table with tuples that have as subset of their prior attributes.

Projectionì€ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ íŠ¹ì • ì—´(colums)ì„ ì„ íƒí•˜ê±°ë‚˜ ì œê±°í•˜ëŠ” ì‘ì—…ì„ ë§í•œë‹¤.
ì¦‰ ë°ì´í„° ì—´ì„ ì„ íƒí•˜ê±°ë‚˜ í•„í„°ë§í•˜ëŠ” ê²ƒì´ë‹¤.
ì´ëŠ” SELECTë¬¸ì˜ ì—´ ëª©ë¡ì„ ì§€ì •í•˜ì—¬ ìˆ˜í–‰ëœë‹¤.

```SQL
SELECT Pname, PRice Manufacturer
FROM Product
WHERE Category = 'Gadgets'
```

**ê³„ì† í—·ê°ˆë¦¬ëŠ” ìš©ì–´ ì •ë¦¬**

* í–‰(row) ë˜ëŠ” ë ˆì½”ë“œ
    * í…Œì´ë¸”ì—ì„œ í•˜ë‚˜ì˜ ë°ì´í„° ìš”ì†Œë¥¼ ë‚˜íƒ€ëƒ„
    * ìˆ˜í‰ë°©í–¥ìœ¼ë¡œ ë‚˜ì—´, ê° í–‰ì€ íŠ¹ì • ì—´ì˜ ë°ì´í„°ë¥¼ í¬í•¨í•¨
* ì—´(column) ë˜ëŠ” ì†ì„±(attribute)
    * í…Œì´ë¸”ì—ì„œ ë°ì´í„° ìœ í˜•ì„ ë‚˜íƒ€ë‚´ëŠ” ì„¸ë¡œì˜ êµ¬ì„± ìš”ì†Œ
    * ìˆ˜ì§ë°©í–¥ìœ¼ë¡œ ë‚˜ì—´, ê° ì—´ì€ íŠ¹ì • ìœ í˜•ì˜ ë°ì´í„°ë¥¼ í¬í•¨í•¨
* íŠœí”Œ(Tuple): ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ record ë˜ëŠ” í–‰(row)ì„ ë‚˜íƒ€ë‚´ëŠ” ê°œë…
    * RDBMSì—ì„œ í…Œì´ë¸”ì€ íŠœí”Œì˜ ëª¨ìŒìœ¼ë¡œ ì´ë£¨ì–´ì ¸ìˆë‹¤.
    * í•˜ë‚˜ì˜ íŠœí”Œì€ ì¼ë ¨ì˜ ê°’ë“¤ì˜ ìˆœì„œìˆëŠ” ì§‘í•©, ê° ê°’ì€ íŠœí”Œì˜ í•˜ë‚˜ì˜ ì†ì„±(attribute)ì— ëŒ€ì‘
    * í…Œì´ë¸”ì—ì„œ ì¡°íšŒëœ ë°ì´í„°ì˜ í•œ í–‰ (ë³´í†µ ë ˆì½”ë“œì™€ ë™ì˜ì–´ë¡œ ì‚¬ìš©ëœë‹¤.)
* í‚¤(key): í…Œì´ë¸”ì—ì„œ ê° í–‰ì„ ê³ ìœ í•˜ê²Œ ì‹ë³„í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ì—´ ë˜ëŠ” ì—´ì˜ ì¡°í•©, ë°ì´í„°ì˜ ì¼ê´€ì„±ê³¼ ì •í™•ì„±ì„ ìœ ì§€í•˜ëŠ”ë° ë§¤ìš° ì¤‘ìš”
    * ê¸°ë³¸ í‚¤(primary key): í…Œì´ë¸”ì—ì„œ ê° í–‰ì„ ê³ ìœ í•˜ê²Œ ì‹ë³„í•˜ëŠ”ë° ì‚¬ìš©í•˜ëŠ” ì—´
        * ì¤‘ë³µë˜ê±°ë‚˜ NULLê°’ í¬í•¨ ë¶ˆê°€
        * ì´ í‚¤ì— ì˜í•´ í…Œì´ë¸”ì˜ ë°ì´í„°ê°€ ì •ë ¬ë˜ê³  ì¸ë±ì‹± ëœë‹¤.
        * í…Œì´ë¸”ì„ ìƒì„±í•  ë–„ CREATE TABLEë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ì„¤ì •
    * ì™¸ë˜ í‚¤(foreign key): ì¼ë°˜ì ìœ¼ë¡œ ë‹¤ë¥¸ í…Œì´ë¸”ê³¼ì˜ ê´€ê³„ë¥¼ ì •ì˜í•˜ëŠ”ë° ì‚¬ìš©
        * í•œ í…Œì´ë¸”ì˜ ì—´ì— ìˆëŠ” ê°’ì´ ë‹¤ë¥¸ í…Œì´ë¸”ì˜ í–‰ì˜ ê¸°ë³¸í‚¤ì™€ ì¼ì¹˜í•˜ëŠ” ê²½ìš° ì‚¬ìš©ë¨
        * FOREIGN KEY í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜
* ì¸ë±ìŠ¤(Index)
    * DBì—ì„œ ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê²€ìƒ‰í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° êµ¬ì¡°
    * ì—´(column)ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ìƒì„±
    * DBì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ê³  ì¿¼ë¦¬ì˜ ì‹¤í–‰ì†ë„ë¥¼ ë†’ì´ëŠ”ë° ì¤‘ìš”í•œ ì—­í• ì„ í•¨
<br>

**Practice 5 - 1**
To make SQL, we need a schema information.
Because we need able and attribute information.
These are defined in schema.

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/4977dca8-fbc1-4888-a9da-f4a8934204aa)

Given each description, make the corresponding SQL and practice it using ACDB.sql

1. Create a query to display the internet PACK_ID, internet SPEED and MONTHLY_PAYMENT (Packages table).
    ```SQL
    SELECT PACK_ID, SPEED, MONTHLY_PAYMENT
    FROM ACDB_PACKAGES
    ```
2. Create a query to display the customer CUSTOMER_ID, FIRST_NAME, LAST_NAME, MAIN_PHONE_NUM, SECONDARY_PHONE_NUM and PACK_ID(Customers table).
    ```SQL
    SELECT CUSTOMER_ID, FIRST_NAME, LAST_NAME, MAIN_PHONE_NUM, SECONDARY_PHONE_NUM, PACK_ID
    FROM ACDB_CUSTOMERS;
    ```
3. Display the FIRST_NAME, LAST_NAME, and PACK_ID for all customers whose LAST_NAME is â€œKingâ€ (Customers table).
    ```SQL
    SELECT FIRST_NAME, LAST_NAME, PACK_ID
    FROM ACDB_CUSTOMERS
    WHERE LAST_NAME = 'King';
    ```
4. Display the FIRST_NAME, LAST_NAME, PACK_ID and MONTHLY_DISCOUNT for all customers with MONTHLY_DISCOUNT less than 10 (Customers table).
    ```SQL
    SELECT FIRST_NAME, LAST_NAME, PACK_ID, MONTHLY_DISCOUNT
    FROM ACDB_CUSTOMERS
    WHERE MONTHLY_DISCOUNT < 10;
    ```
<br>

**Practice 5 - 2**

Given each description, make the corresponding SQL and practice it using ACDB.sql

1. Create a query to display the PACK_ID, SPEED, STRT_DATE (the date when the package became available), MONTHLY_PAYMENT, and MONTHLY_PAYMENT * 12, name the last column â€œY_INCOMEâ€ (Packages table).
    ```SQL
    SELECT PACK_ID, SPEED, STRT_DATE, MONTHLY_PAYMENT, MONTHLY_PAYMENT * 12 AS Y_INCOME
    FROM ACDB_PACKAGES;
    ```
2. Create a query to display the last name concatenated with the FIRST_NAME, separated by space, and MAIN_PHONE_NUMBER concatenated with SECONDARY_PHONE_NUM, separated by comma and space. Name the column heading FULL_NAME and CONTACT_DETAILS respectively. (Customers table).
    ```SQL
    SELECT LAST_NAME || ' ' || FIRST_NAME AS FULL_NAME, MAIN_PHONE_NUM || ', ' || SECONDARY_PHONE_NUM AS CONTACT_DETAILS
    FROM ACDB_CUSTOMERS;
    ```
3. Create a query to display the FIRST_NAME, LAST_NAME, MONTHLY_DISCOUNT and CITY concatenated with STREET, separated by space. Name the column headings: FN, LN, DC and FULL_ADDRESS respectively (Customers table).
    ```SQL
    SELECT FIRST_NAME AS FN, LAST_NAME AS LN, MONTHLY_DISCOUNT AS DC, CITY || ' ' || STREET AS FULL_ADDRESS
    FROM ACDB_CUSTOMERS;
    ```
<br>

**ì£¼ì˜**

1. SQL ëª…ë ¹ì–´ëŠ” ëŒ€ì†Œë¬¸ìë¥¼ êµ¬ë¶„í•˜ì§€ ì•ŠëŠ”ë‹¤.
2. ë°ì´í„° ê°’ì€ ëŒ€ì†Œë¬¸ìë¥¼ êµ¬ë¶„í•œë‹¤.
3. ìƒìˆ˜ì—ëŠ” ' 'ë¥¼ ì‚¬ìš©í•œë‹¤.
<br>

### Operators: LIKE, DISTINCT, ORDER BY

**LIKE: Simple String Pattern Matching**

LIKEì™€ NOT LIKEëŠ” íŒ¨í„´ ë§¤ì¹­ì„ ìˆ˜í–‰í•˜ëŠ” ì—°ì‚°ìì´ë‹¤.
íŠ¹ì • íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ” ë¬¸ìì—´ã…‡ë¥´ ê²€ìƒ‰í•˜ê±°ë‚˜ ì œì™¸í•  ìˆ˜ ìˆë‹¤.

s LIKE p: patter 'p' matches on an attribute 's'
<br><br>
p may contain two special symbols

* %: any sequence of characters
    * a%: aë¡œ ì‹œì‘í•˜ëŠ” ëª¨ë“  ë¬¸ìì—´
    * %a: aë¡œ ëë‚˜ëŠ” ëª¨ë“  ë¬¸ìì—´
    * %a%: aë¥¼ í¬í•¨í•˜ëŠ” ëª¨ë“  ë¬¸ìì—´
* _: any single character
    * h_t: hat, hot ë“±ê³¼ ì¼ì¹˜
    * _ëŠ” ì •í™•íˆ í•˜ë‚˜ì˜ ë¬¸ìì™€ ì¼ì¹˜í•˜ë¯€ë¡œ íŒ¨í„´ì— ëª‡ê°œì˜ _ê°€ ìˆëŠ”ì§€ì— ë”°ë¼ ì¼ì¹˜í•˜ëŠ” ë¬¸ìì—´ì˜ ê¸¸ì´ê°€ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŒ

```SQL
SELECT *
FROM Products
WHERE PName LIKE â€˜%gizmo%
```

products í…Œì´ë¸”ì—ì„œ PName ì—´ì˜ ê°’ ì¤‘ì— gizmoë¥¼ í¬í•¨í•˜ëŠ” ëª¨ë“  íŠœí”Œì„ ì„ íƒí•˜ë¼. ë¼ëŠ” ëœ»ì´ëœë‹¤.
<br>

NOT LIKE ì—°ì‚°ìëŠ” LIKEì™€ ì •ë°˜ëŒ€ì˜ ì—­í• ì„ í•œë‹¤.
ì£¼ì–´ì§„ ë¬¸ìì—´ì´ ì§€ì •ëœ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ”ì§€ë¥¼ í™•ì¸í•˜ëŠ” ê²ƒì´ë‹¤.

```SQL
SELECT *
FROM Products
WHERE PName NOT LIKE â€˜%gizmo%
```
ì´ ì¿¼ë¦¬ëŠ” PNameì—´ì— gizmoë¥¼ í¬í•¨í•˜ì§€ ì•ŠëŠ” ëª¨ë“  íŠœí”Œì„ ê²€ìƒ‰í•  ê²ƒì´ë‹¤.
<br>

**DISTINCT: Eliminating Duplicates**

DISTINCT ì—°ì‚°ìëŠ” SQL ì¿¼ë¦¬ ê²°ê³¼ì—ì„œ ì¤‘ë³µëœ í–‰ì„ ì œê±°í•˜ì—¬ ê²°ê³¼ì— ê° ê°’ì´ í•œ ë²ˆë§Œ ë‚˜íƒ€ë‚˜ë„ë¡ í•œë‹¤.

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/f03dd6b7-a50d-4d86-8c8c-8af0a4a7235f)


í…Œì´ë¸”ì„ ìœ„ ì²˜ëŸ¼ ë§Œë“¤ì–´ ë†“ì€ ìƒíƒœì—ì„œ

```SQL
SELECT Category
FROM Product
```

ë¼ëŠ” ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•´ì„œ Categoryë¥¼ ì‚´í´ë³´ë©´ 

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/79ca3c67-98e1-48e0-ac94-0eac112a3e53)

ë‹¤ìŒê³¼ ê°™ì´ ì¶œë ¥ëœë‹¤.
ê·¸ëŸ¬ë‚˜

```SQL
SELECT DISTINCT Category
FROM Product
```

ì„ ì‹¤í–‰í•´ì„œ ì¤‘ë³µë˜ëŠ” ê°’ì„ ì œê±°í•˜ë©´

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/b86941fc-c17d-4390-97cd-3a0793ba34bf)

ë‹¤ìŒê³¼ ê°™ì´ ì¶œë ¥ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
<br>

**Practice 5 - 3**

Given each description, make the corresponding SQL and practice it using ACDB.sql

1. Create a query to display unique CITY from the Customers table.
    ```SQL
    SELECT DISTINCT CITY
    FROM ACDB_CUSTOMERS;
    ```
2. Create a query to display unique combination of CITY and STATE from Customers table.
    ```SQL
    SELECT DISTINCT CITY, STATE
    FROM ACDB_CUSTOMERS;
    ```
3. Display the FIRST_NAME and MONTHLY_DISCOUNT for all customers whose FIRST_NAME ends with an e (Customers table).
    ```SQL
    SELECT FIRST_NAME, MONTHLY_DISCOUNT
    FROM ACDB_CUSTOMERS
    WHERE FIRST_NAME LIKE '%e';
    ```
4. Display the LAST_NAME and PACK_ID for all customers where the second letter of their last name is d (Customers table).
    ```SQL
    SELECT LAST_NAME, PACK_ID 
    FROM ACDB_CUSTOMERS
    WHERE LAST_NAME LIKE '_d%';
    ```
<br>

**ORDER BY: Sorting the Results**

ORDER BY ì ˆì€ SQL ì¿¼ë¦¬ ê²°ê³¼ë¥¼ íŠ¹ì • ì—´ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.
ì´ë¥¼ í†µí•´ ì¿¼ë¦¬ê²°ê³¼ë¥¼ ì›í•˜ëŠ” ìˆœì„œë¡œ ì •ë ¬í•  ìˆ˜ ìˆë‹¤.

* SELECT ì ˆì€ ì„ íƒí•  ì—´ì„ ì§€ì •
* FROM ì ˆì€ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ í…Œì´ë¸”ì„ ì§€ì •
* ORDER BYì ˆì€ ì •ë ¬í•  ì—´ì„ ì§€ì •
* ì •ë ¬ ë°©í–¥ì€ ì˜µì…˜ìœ¼ë¡œ ASC(ì˜¤ë¦„ì°¨ìˆœ, ê¸°ë³¸ê°’) ë˜ëŠ” DESC(ë‚´ë¦¼ì°¨ìˆœ)
ì¤‘ í•˜ë‚˜ ì„ íƒ

<br>

```SQL
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category=â€˜gizmoâ€™ AND Price > 50
ORDER BY Price DESC;
```

ì´ SQL ì¿¼ë¦¬ëŠ” Product í…Œì´ë¸”ì—ì„œ Categoryê°€ 'gizmo'ì´ê³  Priceê°€ 50ë³´ë‹¤ í° ì œí’ˆì„ ì„ íƒí•œ í›„, Priceë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ PName, Price, Manufacturer ì—´ì„ í™”ë©´ì— ì¶œë ¥í•œë‹¤.
<br>

```SQL
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category=â€˜gizmoâ€™ AND Price > 50
ORDER BY Price, PName
```

ì´ SQL ì¿¼ë¦¬ëŠ” Product í…Œì´ë¸”ì—ì„œ Categoryê°€ 'gizmo'ì´ê³  Priceê°€ 50ë³´ë‹¤ í° ì œí’ˆì„ ì„ íƒí•œ í›„, ë¨¼ì € Priceë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  ê·¸ ë‹¤ìŒì—ëŠ” PNameì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ PName, Price, Manufacturer ì—´ì„ í™”ë©´ì— ì¶œë ¥í•œë‹¤.
<br>

**Between**

BETWEEN ì—°ì‚°ìëŠ” ì£¼ì–´ì§„ ë²”ìœ„ ì•ˆì— ìˆëŠ” ê°’ë“¤ì„ ì„ íƒí•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.
ì´ ì—°ì‚°ìëŠ” ì£¼ë¡œ ìˆ«ì, ë‚ ì§œ ë˜ëŠ” ë¬¸ìì—´ ê°’ë“¤ì˜ ë²”ìœ„ë¥¼ ì§€ì •í•  ë•Œ ì‚¬ìš©ëœë‹¤.

ë¹„êµí• ê°’ BETWEEN ë²”ìœ„ì‹œì‘ê°’ AND ë²”ìœ„ëê°’

í˜•íƒœë¡œ ì…ë ¥í•œë‹¤.
<br>

```SQL
SELECT *
FROM Product
WHERE price BETWEEN 10 AND 100
```

ì´ ì¿¼ë¦¬ëŠ” product í…Œì´ë¸”ì—ì„œ priceì—´ì´ 10ì—ì„œ 100ì‚¬ì´ì— ìˆëŠ” ì œí’ˆì„ ì°¾ì•„ë³´ì—¬ì¤€ë‹¤.

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/23b73d42-492a-452c-af7a-0f781df2ac7f)
<br>

**Practice 5 - 4**

Given each description, make the corresponding SQL and practice it using ACDB.sql

1. Display the FIRST_NAME , JOIN_DATE,, and PACK_ID for all customers who donâ€™t have the letter a in their FIRST_NAME. Order the query in ascending order by PACK_ID (Customers table).
    ```SQL
    SELECT FIRST_NAME, JOIN_DATE, PACK_ID
    FROM ACDB_CUSTOMERS
    WHERE FIRST_NAME NOT LIKE '%a%'
    ORDER BY PACK_ID ASC;
    ```
2. Display the FIRST_NAME, JOIN_DATE, MONTHLY_DISCOUNT, and PACK_ID for all customers whose MONTHLY_DISCOUNT is over 28. Order the query in ascending order by MONTHLY DISCOUNT and PACK_ID (Customers table)
    ```SQL
    SELECT FIRST_NAME, JOIN_DATE, MONTHLY_DISCOUNT, PACK_ID
    FROM ACDB_CUSTOMERS
    WHERE MONTHLY_DISCOUNT > 28
    ORDER BY MONTHLY_DISCOUNT ASC, PACK_ID ASC;
    ```
    <br> ì´ë–„ ASCëŠ” ìƒëµí•  ìˆ˜ ìˆë‹¤.
3. Order the results of the previous problem (#2) in descending order by MONTHLY DISCOUNT and then in ascending order by PACK_ID (Customers table)
    ```SQL
    SELECT FIRST_NAME, JOIN_DATE, MONTHLY_DISCOUNT, PACK_ID
    FROM ACDB_CUSTOMERS
    WHERE MONTHLY_DISCOUNT > 28
    ORDER BY MONTHLY_DISCOUNT DESC, PACK_ID ASC;
    ```
4. Display the FIRST_NAME, JOIN_DATE, MONTHLY_DISCOUNT where MONTHLY_DISCOUNT is between 28 and 30 (Customers table)
    ```SQL
    SELECT FIRST_NAME, JOIN_DATE, MONTHLY_DISCOUNT
    FROM ACDB_CUSTOMERS
    WHERE MONTHLY_DISCOUNT BETWEEN 28 AND 30;
    ```
<br>

### Multi-table queries

ë‹¤ì¤‘ í…Œì´ë¸” ì¿¼ë¦¬ëŠ” RDBMSì—ì„œ ì—¬ëŸ¬ ê°œì˜ í…Œì´ë¸”ì„ ì¡°ì¸í•˜ê±°ë‚˜ ì—°ê²°í•˜ì—¬ ë°ì´í„°ë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ ì¡°ì‘í•˜ëŠ” ì¿¼ë¦¬ì´ë‹¤.
ì´ë¥¼ í™œìš©í•˜ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë³µì¡í•œ ë°ìë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì¶”ì¶œí•˜ê³  ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.

ì¿¼ë¦¬: ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì •ë³´ë¥¼ ìš”ì²­í•˜ê±°ë‚˜ ê²€ìƒ‰í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ëª…ë ¹ì–´ë‚˜ ë¬¸ì¥

í…Œì´ë¸”ì„ ë‘ê°œ ì´ìƒ ë‹¤ë£¨ê¸° ìœ„í•´ foreign keyì™€ joinì„ ë§ì´ ì‚¬ìš©í•œë‹¤.

* Foregin Key Constraints
    * ì™¸ë˜ í‚¤ëŠ” í•œ í…Œì´ë¸”ì˜ ì—´(column)ì´ ë‹¤ë¥¸ í…Œì´ë¸”ì˜ ê¸°ë³¸í‚¤(primary key)ì™€ ê´€ë ¨ë˜ì–´ ìˆìŒì„ ë‚˜íƒ€ë‚´ëŠ”ë° ì‚¬ìš©í•œë‹¤.
    * í•œ í…Œì´ë¸”ì˜ ì™¸ë˜í‚¤ëŠ” ë‹¤ë¥¸ í…Œì´ë¸”ì˜ ê¸°ë³¸í‚¤ë¥¼ ì°¸ì¡°í•˜ì—¬ ë‘ í…Œì´ë¸” ê°„ì˜ ê´€ê³„ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒ
* Join
    * ë‘ ê°œ ì´ìƒì˜ í…Œì´ë¸”ì„ ì—°ê²°í•˜ê³  ì¡°ì¸ ì¡°ê±´ì„ ì§€ì •í•˜ì—¬ í…Œì´ë¸” ê°„ì˜ ê´€ê³„ë¥¼ ì •ì˜
    * ì¼ë°˜ì ìœ¼ë¡œ ë‘ í…Œì´ë¸”ê°„ì—ëŠ” ê´€ê³„ê°€ ìˆì–´ì•¼ í•˜ë©°, ê¸°ë³¸í‚¤ì™€ ì™¸ë˜í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜í•œë‹¤.

**Foreign Key Constraints**

SQL queires can have two or more tables.
This means taht we need to find information that is from multiple tables.
Thoese tables have the relation each other.
<br><br>
If there is two tables like this.

![image](https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/6b6bab36-e22f-4b28-afe8-785ef3ad6bab)

And if we want to impose the following constraint:
"a student must appear in the Students table to enroll in a class"
<br><br>
It means only student registered in students table can enroll in courses.
We cannot find information form only one table like Students or Enrolled.
By combinning thsi two table(information) together, we can find this kind of useful information.

In upper situation, student_id column shoud be set into foreign key, and this key should we connected to sid column in Students table.

So quries should be like

```SQL
CREATE TABLE Enrolled(
student_id CHAR(20),
cid CHAR(20),
grade CHAR(10),
PRIMARY KEY (student_id, cid),
FOREIGN KEY (student_id) REFERENCES Students(sid)
);
```

**ì™¸ë˜í‚¤ ì œì•½ì¡°ê±´**: ì™¸ë˜ í‚¤í…Œì´ë¸”ì´ ì°¸ì¡°í•˜ëŠ” í…Œì´ë¸”ì˜ ì—´ì€ ë°˜ë“œì‹œ primary keyì´ê±°ë‚˜ unique ì œì•½ ì¡°ê±´ì´ ì„¤ì •ë˜ì–´ìˆì–´ì•¼í•œë‹¤.
<br><br>
ì´ ì¡°ê±´ì€ í…Œì´ë¸” ê°„ì˜ ê´€ê³„ë¥¼ ìœ ì§€í•˜ê³  ë°ì´í„° ë¬´ê²°ì„±ì„ ë³´í˜¸í•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.
ë”°ë¼ì„œ ì™¸ë˜ í‚¤ê°€ ì°¸ì¡°í•˜ëŠ” í…Œì´ë¸”ì˜ ê°’ì´ ì—†ëŠ” ê²½ìš°, ì¦‰ í•´ë‹¹ ì™¸ë˜ í‚¤ì™€ ì¼ì¹˜í•˜ëŠ” ê°’ì´ ì—†ëŠ” ê²½ìš°ì—ëŠ” INSERT ì‘ì—…ì´ ê±°ë¶€ëœë‹¤.
<br><br>
ì˜ˆë¥¼ ë“¤ì–´ Enrolled í…Œì´ë¸”ì˜ student_idì—´ì´ Students í…Œì´ë¸”ì˜ sid ì—´ì„ ì™¸ë˜í‚¤ë¡œ ì°¸ì¡°í•  ë•Œ, Enrolled í…Œì´ë¸”ì— ìƒˆë¡œìš´ íŠœí”Œ(ë ˆì½”ë“œ)ë¥¼ ì‚½ì…í•˜ë ¤ê³  í•˜ì§€ë§Œ í•´ë‹¹ student_id ê°’ì´ Students í…Œì´ë¸”ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì™¸ë˜ í‚¤ ì œì•½ ì¡°ê±´ì— ìœ„ë°°ë˜ì–´ ì‚½ì…ì‘ì—…ì´ ê±°ë¶€ëœë‹¤.
<br>

**What if we delete a student?**

* Disallow the delte  í•™ìƒ ì‚­ì œ ê¸ˆì§€ <br>
    ì™¸ë˜ í‚¤ ì œì•½ ì¡°ê±´ì— ì˜í•´ ë‹¤ë¥¸ í…Œì´ë¸”ì— í•´ë‹¹ í•™ìƒê³¼ ê´€ë ¨ëœ ë ˆì½”ë“œê°€ ìˆì„ ê²½ìš°, í•™ìƒì„ ì‚­ì œí•  ìˆ˜ ì—†ë‹¤.
    If we delete the student from only student table, the constraints are not stisfied. -> disallowed the operation
* Remove all the courses for that student <br>
    We should delete all related information about student(= courses) if we want to delete student data.
    í•™ìƒì„ ì‚­ì œí•¨ìœ¼ë¡œì¨ í•´ë‹¹ í•™ìƒì´ ìˆ˜ê°•í•œ ëª¨ë“  ê³¼ëª© ë‚´ì—­ë„ í•¨ê»˜ ì‚­ì œë˜ëŠ” ê²ƒ: ë°ì´í„°ì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•˜ë©´ì„œë„ í•™ìƒ ì‚­ì œë¥¼ í—ˆìš©í•˜ëŠ” ë°©ë²•
* SQL allows a third via NULL (not yet covered)  NULL í—ˆìš© <br>
    ON DELETE SET NULL ì˜µì…˜ì„ í†µí•´ ì™¸ë˜ í‚¤ê°€ ì°¸ì¡°í•˜ëŠ” ê°’ì´ ì‚­ì œë  ë•Œ í•´ë‹¹ ì™¸ë˜ í‚¤ë¥¼ NULLë¡œ ì„¤ì •í•˜ëŠ” ê²ƒì„ í—ˆìš©í•œë‹¤. ë”°ë¼ì„œ í•´ë‹¹ í•™ìƒì´ ìˆ˜ê°•í•œ ë‚´ì—­ì€ ìœ ì§€ë˜ì§€ë§Œ, í•™ìƒì˜ ì‹ë³„ìëŠ” NULLë¡œ ì„¤ì •ëœë‹¤.
<br>

**Join**

Operation to specify the relation between different tables.

By using join operation, we can finde new information that can be inferred from multiple tables that can not retrieve from single table.

<img width="333" alt="image" src="https://github.com/orieasy1/24-1-Programming-Study/assets/129071350/fbaca9bf-0eee-4e39-b9cc-15266547b8c7">

In this example, Manufacturer is foregin Key and it connects Product table with Company table.
CName is primary key at Company table and PName is primary key at Product table.
<br><br>
Let say we want to find all products under $200 manufactured in Japan and reutrn their names and price.

There is two condition.
First one is price information(under $200), and second one is country information(in Japan).
Price information is in the Prodcut table and country information is in Company table.
They are seperately stored in different tables.
So We need Join opertion.

ë”°ë¼ì„œ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•´ì¤„ ìˆ˜ ìˆë‹¤. (ë‘ ì¿¼ë¦¬ëŠ” ë™ì¼í•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.)

ì´ ì¿¼ë¦¬ëŠ” ì•”ì‹œì ì¸ INNER JOINì„ ì‚¬ìš©í•œë‹¤.

```SQL
SELECT PName, Price
FROM Product, Company
WHERE Manufacturer = CName
AND Country=â€˜Japanâ€™
AND Price <= 200
```

ëª…ì‹œì ì¸ INNER JOIN ì‚¬ìš©í•œë‹¤.
IN í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ Product í…Œì´ë¸”ê³¼ Company í…Œì´ë¸”ì„ ëª…ì‹œì ìœ¼ë¡œ ê²°í•©í•˜ê³ , ON ì ˆì—ì„œ ì¡°ì¸ ì¡°ê±´ì„ ì§€ì •í•œë‹¤.

```SQL
SELECT PName, Price
FROM Product
JOIN Company ON Manufacturer = Cname
AND Country=â€˜Japanâ€™
WHERE Price <= 200
```

Join êµ¬ë¬¸ ì¢…ë¥˜

* INNER JOIN
    * ê°€ì¥ ë„ë¦¬ ì“°ì„
    * ë³´í†µ JOINì´ë¼ í•˜ë©´ INNER JOINì„ ìƒê°
    * ì¡°ì¸í‚¤ì— í•´ë‹¹í•˜ëŠ” ê° í…Œì´ë¸”ì˜ ì—´ê°’ì„ ë¹„êµ‘í•´ ì¡°ê±´ì— ë§ëŠ” ê°’ì„ ê²€ìƒ‰
    ```SQL
    SELECT ì—´ì´ë¦„
    FROM í…Œì´ë¸”1ëª…
    INNER JOIN í…Œì´ë¸”2ëª… ON í…Œì´ë¸”1ì˜ì—´ = í…Œì´ë¸”2ì˜ì—´
    WHERE ê²€ìƒ‰ì¡°ê±´
    ```
* OUTER JOIN: ë‹¤ë¥¸ í…Œì´ë¸”ì— ìˆëŠ” í–‰ì—ì„œ ì¼ì¹˜ í•­ëª©ì´ ì•„ë‹Œ í–‰ì„ ì¡°í•©í•´ ê²€ìƒ‰í•´ì•¼í•  ë•Œ ì‚¬ìš©
    * LEFT OUTER JOIN: í…Œì´ë¸”1ì„ ê¸°ì¤€ìœ¼ë¡œ í…Œì´ë¸”2ë¥¼ ì¡°ì¸ 
    ```SQL
    SELECT * ì•„ë‹˜ ì—´ì´ë¦„
    FROM í…Œì´ë¸”1ëª…
    LEFT JOIN í…Œì´ë¸”2ëª… ON í…Œì´ë¸”1ì˜ì—´ = í…Œì´ë¸”2ì˜ì—´
    WHERE ê²€ìƒ‰ì¡°ê±´
    ```
    * RIGHT OUTER JOIN: í…Œì´ë¸”2ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í…Œì´ë¸”1ì„ ì¡°ì¸
    ```SQL
    SELECT * ì•„ë‹˜ ì—´ì´ë¦„
    FROM í…Œì´ë¸”1ëª…
    RIGHT JOIN í…Œì´ë¸”2ëª… ON í…Œì´ë¸”1ì˜ì—´ = í…Œì´ë¸”2ì˜ì—´
    WHERE ê²€ìƒ‰ì¡°ê±´
    ```
    * FULL OUTER JOIN
        * ì‹¤ì œë¡œ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë“œë¬¼ë‹¤.
        * ì–‘ìª½ í…Œì´ë¸”ì˜ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” í–‰ë„ ëª¨ë‘ ê²€ìƒ‰, ì¡°ì¸ ì¡°ê±´ì— ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” í•­ëª©ê³¼ ì¼ì¹˜í•˜ëŠ” í•­ëª© ëª¨ë‘ í‘œì‹œ
        * DB ë”©ìì¸ì´ë‚˜ ë°ì´í„°ì— ë¬¸ì œê°€ ìˆì„ë•Œ, ë°ì´í„° ëˆ„ë½ì´ë‚˜ ì˜¤ë¥˜ë¥¼ ì°¾ì•„ë‚¼ ë•Œ ìœ ìš©
    ```SQL
    SELECT * ì•„ë‹˜ ì—´ì´ë¦„
    FROM í…Œì´ë¸”1ëª…
    FULL JOIN í…Œì´ë¸”2ëª… ON í…Œì´ë¸”1ì˜ì—´ = í…Œì´ë¸”2ì˜ì—´
    WHERE ê²€ìƒ‰ì¡°ê±´
    ```
* CROSS JOIN
    * ìì£¼ ì‚¬ìš©í•˜ì§€ëŠ” ì•ŠìŒ
    * ê° í…Œì´ë¸”ì˜ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¡°í•©í•œ ë°ì´í„°ê°€ í•„ìš”í•  ê²½ìš° ì‚¬ìš©
    ```SQL
    SELECT * ì•„ë‹˜ ì—´ì´ë¦„
    FROM í…Œì´ë¸”1ëª…
        CROSS JOIN í…Œì´ë¸”2ëª…
    WHERE ê²€ìƒ‰ì¡°ê±´
    ``` 
<br>

**Practice 5 - 5**

Given each description, make the corresponding SQL and practice it using ACDB.sql

1. Write a query to display FIRST_NAME, LAST_NAME, PACK_ID and SPEED for all customers. (Customers and Packages)
    ```SQL
    SELECT c.FIRST_NAME, c.LAST_NAME, c.PACK_ID, p.SPEED
    FROM ACDB_CUSTOMERS c
    JOIN ACDB_PACKAGES p ON c.PACK_ID = p.PACK_ID;
    ```
2. Display the PACK_ID, SPEED, MONTHLY_PAYMENT and SECTOR_ID for all packages (Packages and Sectors tables).
    ```SQL
    SELECT p.PACK_ID, p.SPEED, p.MONTHLY_PAYMENT, s.SECTOR_NAME
    FROM ACDB_PACKAGES p
    JOIN ACDB_SECTORS s ON p.SECTOR_ID = s.SECTOR_ID;
    ```
3. Display the customer LAST_NAME, FIRST_NAME, PACK_ID, SPEED, MONTHLY_PAYMENT and SECTOR_NAME for all customers (Customers, Packages and Sectors tables).
    ```SQL
    SELECT c.LAST_NAME, c.FIRST_NAME, c.PACK_ID, p.SPEED, p.MONTHLY_PAYMENT, s.SECTOR_NAME
    FROM ACDB_CUSTOMERS c
    JOIN ACDB_PACKAGES p ON c.PACK_ID = p.PACK_ID
    JOIN ACDB_SECTORS s ON p.SECTOR_ID = s.SECTOR_ID;
    ```
4. Display the customer LAST_NAME, FIRST_NAME, PACK_ID, SPEED, MONTHLY_PAYMENT and SECTOR_NAME for all customers in the â€˜Businessâ€™ sector (Customers, Packages and Sectors tables).
    * You may check the data stored in Sectors table
    ```SQL
    SELECT c.LAST_NAME, c.FIRST_NAME, c.PACK_ID, p.SPEED, p.MONTHLY_PAYMENT, s.SECTOR_NAME
    FROM ACDB_CUSTOMERS c
    JOIN ACDB_PACKAGES p ON c.PACK_ID = p.PACK_ID
    JOIN ACDB_SECTORS s ON p.SECTOR_ID = s.SECTOR_ID
    WHERE s.SECTOR_NAME = 'Business';
    ```
<br>

**SET OPERATORS  ì§‘í•© ì—°ì‚°ì**

RDBMSì—ì„œ ì‚¬ìš©ë˜ëŠ” ì—°ì‚°ìë¡œ ë‘ ê°œ ì´ìƒì˜ ì¿¼ë¦¬ ê²°ê³¼ ì§‘í•©ì„ ê²°í•©í•˜ê±°ë‚˜ ì¡°ì‘í•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.
ì¢…ë¥˜ëŠ” ì´ 4ê°€ì§€ê°€ ìˆë‹¤.

* INTERSECT(Q1 âˆ© Q2): ë‘ ê°œì˜ ì§‘í•©ê°„ì— ê³µí†µëœ í–‰ì„ ë°˜í™˜
    * ì—¬ëŸ¬ ê°œì˜ SQLë¬¸ì˜ ê²°ê³¼ì— ëŒ€í•œ êµì§‘í•©
    * Find the intersection of the result of the first SQL query and them of the second SQL query.
    ```SQL
    SELECT R.A
    FROM R, S
    WHERE R.A=S.A
        INTERSECT
    SELECT R.A
    FROM R, T
    WHERE R.A=T.A
    ```
    * ê²°êµ­ ë°˜í™˜ë˜ëŠ” ë¶€ë¶„: {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘ . ğ´} âˆ© {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘¡. ğ´} <br>R í…Œì´ë¸”ê³¼ S í…Œì´ë¸” ê°„ì˜ A ì—´ ê°’ê³¼ R í…Œì´ë¸”ê³¼ T í…Œì´ë¸” ê°„ì˜ A ì—´ ê°’ì´ ë™ì¼í•œ í–‰ì˜ ì§‘í•©ì„ ë°˜í™˜
* UNION(Q1 + Q2): ë‘ ê°œ ì´ìƒì˜ ì§‘í•©ì„ í•©ì¹¨, ì¤‘ë³µëœ í–‰ì€ í•˜ë‚˜ì˜ í–‰ìœ¼ë¡œ ì²˜ë¦¬
    * ì—¬ëŸ¬ ê°œì˜ SQLë¬¸ì˜ ê²°ê³¼ì— ëŒ€í•œ í•©ì§‘í•©
    * Union operater will return only distinct rows that appear in either(ë‘˜ ì¤‘ í•˜ë‚˜ì˜) result. +remove duplicates
    * It finds the union of the result of the first SQL that of the second SQL
    ```SQL
    SELECT R.A
    FROM R, S
    WHERE R.A=S.A
        UNION
    SELECT R.A
    FROM R, T
    WHERE R.A=T.A
    ```
    * ê²°êµ­ ë°˜í™˜ë˜ëŠ” ë¶€ë¶„: {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘ . ğ´} âˆª {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘¡. ğ´} <br> R í…Œì´ë¸”ì˜ A ì—´ ê°’ì´ S í…Œì´ë¸”ì˜ A ì—´ ê°’ ë˜ëŠ” T í…Œì´ë¸”ì˜ A ì—´ ê°’ê³¼ ë™ì¼í•œ ëª¨ë“  ê³ ìœ í•œ ê°’ì˜ ì§‘í•©ì´ ë°˜í™˜(ì¤‘ë³µ ì œì™¸)
* UNION ALL(Q1 + Q2): UNIONê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ ì¤‘ë³µëœ í–‰ì„ ëª¨ë‘ ìœ ì§€
    * ì—¬ëŸ¬ê°œì˜ SQLë¬¸ì— ëŒ€í•œ í•©ì§‘í•©, ì¤‘ë³µëœ í–‰ë„ ê·¸ëŒ€ë¡œ í‘œì‹œ
    * It finds the union of the result of the first SQL that of the second SQL, including duplicates.
    ```SQL
    SELECT R.A
    FROM R, S
    WHERE R.A=S.A
        UNION ALL
    SELECT R.A
    FROM R, T
    WHERE R.A=T.A
    ```
    * ê²°êµ­ ë°˜í™˜ë˜ëŠ” ë¶€ë¶„: {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘ . ğ´} âˆª {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘¡. ğ´} (ì¤‘ë³µ í¬í•¨)
* MINUS(ë˜ëŠ” EXCEPT): ì²« ë²ˆì§¸ ì§‘í•©ì—ì„œ ë‘ë²ˆì§¸ ì§‘í•©ê³¼ ì¤‘ë³µë˜ì§€ ì•ŠëŠ” í–‰ì„ ë°˜í™˜
    * ì•ì˜ SQLë¬¸ì˜ ê²¨ë¡œê°€ì—ì„œ ë’¤ì˜ SQLë¬¸ì˜ ê²¨ë¡œê°€ì— ëŒ€í•œ ì°¨ì§‘í•©
    * Requires 2 operands where each one is mapped to on SQL. The result of excluding result 2 from result 1 is returned.
    ```SQL
    SELECT R.A
    FROM R, S
    WHERE R.A=S.A
        MINUS
    SELECT R.A
    FROM R, T
    WHERE R.A=T.A 
    ```
    * ê²°êµ­ ë°˜í™˜ë˜ëŠ” ë¶€ë¶„:  {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘ . ğ´} - {ğ‘Ÿ. ğ´ |ğ‘Ÿ. ğ´ = ğ‘¡. ğ´}
<br>

**+ ì¿¼ë¦¬ ì½ëŠ” ë°©ì‹**

```SQL
SELECT R.A
FROM R, S
WHERE R.A=S.A
```

ì´ë ‡ê²Œ ì¿¼ë¦¬ê°€ ìˆìœ¼ë©´

FROM ì ˆ: R í…Œì´ë¸”ê³¼ S í…Œì´ë¸”ì„ ì„ íƒ<br>
WHERE ì ˆ: R í…Œì´ë¸”ì˜ A ì—´ê³¼ S í…Œì´ë¸”ì˜ A ì—´ì„ ë¹„êµí•˜ì—¬, ë‘ ì—´ì˜ ê°’ì´ ì¼ì¹˜í•˜ëŠ” í–‰ì„ ì„ íƒ <br>
SELECT ì ˆ: ë„ì¶œë˜ ê²°ê³¼ì—ì„œ R í…Œì´ë¸”ì˜ A ì—´ì„ ì„ íƒí•˜ì—¬ ë°˜í™˜

ìœ¼ë¡œ ì´í•´í•  ê²ƒ!!
<br>

**Practice 6**

1. When we have the following two conditions,
    A. CUSTOMER_ID who get MONTHLY_DISCOUNT over 5 (i.e., > 5 )
    B. CUSTOMER_ID who pay monthly over 100 (i.e., > 100)
    -> Find the following results and compare them: 1) A, 2) B, and 3) A INTERSECT B
    ```SQL
    SELECT CUSTOMER_ID
    FROM ACDB_CUSTOMERS
    WHERE MONTHLY_DISCOUNT > 5
        INTERSECT
    SELECT CUSTOMER_ID
    FROM ACDB_CUSTOMERS
    WHERE MONTHLY_PAYMENT > 100;
    ```
2. When we have the following two conditions, solve the problem
    A. Cities of customers who live in â€˜Californiaâ€™
    B. Cities of customers who include in â€˜Businessâ€™ sector
    -> Find the following results and compare them:1) A, 2) B, 3) A UNION B, 4) A UNION ALL B
    ```SQL
    SELECT CITY
    FROM ACDB_CUSTOMERS
    WHERE STATE = 'California'
        UNION
    SELECT CITY
    FROM ACDB_CUSTOMERS
    WHERE SECTOR = 'Business';
    ```

    ```SQL
    SELECT CITY
    FROM ACDB_CUSTOMERS
    WHERE STATE = 'California'
            UNION ALL
    SELECT CITY
    FROM ACDB_CUSTOMERS
    WHERE SECTOR = 'Business';
    ```
3. When we have the following two conditions, solve the problem
    A. Names of customers who include in â€˜Privateâ€™ sector
    B. Names of customers who live in â€˜Seattleâ€™ or â€˜San Francisoâ€™
    -> Find the following results and compare them:  1) A, 2) B, and 3) A MINUS B
    ```SQL
    SELECT NAME
    FROM ACDB_CUSTOMERS
    WHERE SECTOR = 'Private'
        MINUS
    SELECT NAME
    FROM ACDB_CUSTOMERS
    WHERE CITY IN ('Seattle', 'San Francisco');
    ```