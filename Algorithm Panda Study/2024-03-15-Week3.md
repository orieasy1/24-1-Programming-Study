<h1>알고리즘 스터디 3주차 일지</h1>

## Section 1: Data Structure

<h3>개념정리: 스택과 큐</h3>
스택과 큐는 배열에서 발전된 형태의 자료구조이다.
구조는 비슷하지만 처리방식이 다르다는 특징이 있다.

**스택**

스택은 스택을 쌓아올리 듯 데이터를 쌓아올리는 구조이다.
삽입과 삭제 연산이 후입 선출(Last in first out) 즉 마지막에 들어온 값이 제일 먼저 나가는 형식으로 이루어지며 삽입과 삭제가 한 쪽에서만 일어나는 특징이 있다.
실제로 top부분에서만 연산이 일어난다.
새 값이 스택에 들어가면 top이 새값을 가리킨다.
스택에서 값을 빼낼 때 pop은 top이 가리키는 값을 스택에서 빼게 되어있으므로 결과적으로는 가장 마지막에 넣었던 값이 나오게 된다.

* top: 상비과 삭제가 일어나는 위치
* push: top의 위치에 새로운 데이터를 삽입하는 연산
* pop: top의 윛에 현재 있는 데이터를 삭제하고 확인하는 연산
* peek: top 위치에 현재있는 데이터를 단순 확인하는 연산

스택은 주로 우선 탐색, 백트래킹 종류에 주로 사용된다.
재귀 함수 알고리즘 원리와 매우 유사하기 때문에 실제로 구현 시 재귀함수를 많이 쓰긴한다.
큐보다 구조가 독특하기 때문에 응용하는 문제가 많이 출제된다.
<br>

**재귀 함수 알고리즘과 스택의 관계**

:재귀함수가 호출될 때마다 해당 호출의 실행정보는 스택에 저장된다.
<br><br>
재귀 함수 호출은 함수가 자신을 다시 호출하는 것을 의미한다.
재귀 함수는 종료 조건을 만족할 때까지 자기 자신을 호출하며 종료 조건이 없으면 무한한 재귀호출이 발생할 수 있다.
반복적인 작업이나 자료구조를 다룰 때, 순환적인 문제를 해결할 때 사용하면 좋다.
<br><br>
재귀 함수를 호출하게 되면 현재 함수의 실행을 일시 중지하고 새로운 함수의 호출을 처리하기 위한 메모리 공간이 할당되어야 한다.
재귀 함수는 자신을 호출할 때마다 현재 상태 즉 호출정보(매개변수, 지역변수 등)를 스택 프레임이라고 부르는 메모리 공간에 저장한다.
재귀 함수의 이러한 반복적인 호출은 스택에 여러 프레임을 쌓게 되고 종료 조건이 만족되면 역순으로 스택 프레임을 해제하고 각각의 호출은 결과를 반환하고 메모리에서 제거된다.
<br>

**큐**

큐는 삽입과 삭제 연산이 선입선출로 이루어지는 자료구조이다.
스택과 다르게 먼저 들어온 데이터가 먼저 나간다.
삽입과 삭제가 양방향에서 이루어지는 것을 확인할 수 있다.
새 값의 추가는 큐의 rear에서 이루어지고, 삭제는 큐의 front에서 이루어진다.

* rear: 큐에서 가장 끝 데이터를 가리키는 영역
* front: 큐에서 가장 앞의 데이터를 가리키는 영역
* add: rear부분에 새롱누 데이터를 삽입하는 연산
* poll: front부분에 있는데이터를 삭제하고 확인하는 연산
* peek: 큐의 맨앞(front)에 있는 데이터를 확인하는데 사용하는 연산

큐는 너비 우선 탐색에서 자주 사용한다.

우선순위 큐
보통 힙 자료형을 사용해서 구현한는데, 값이 들어간 순서와 상관없이 우선순위가 높은 데이터가 먼저 나오는 자료구조이다.
큐 설정에 따라 front에 항상 최댓값 또는 최솟값이 위치한다.


<h3>백준 11286: 절댓값 힙 구현하기</h3>

* 절댓값이 가장 작은 값을 출력한 후 그 값을 배열에서 제거
* 절댓값이 가장 작은 값이 여러 개일 경우 그중에서 가장 작은 수를 출력 후 그 값을 배열에서 제거

절댓값이 같다면 음수를 우선 출력하라는 뜻

* 연산의 개수 N
* 연산과 관련된 정보를 나타내는 정수 x
* x가 0이 아니라면 뱅려에 x라는 값을 추가

**해결방안 고민**

1. 입력을 받아옴
2. 우선순위 큐를 사용하여 최소 힙을 구현
    데이터가 새로 삽입될때마다 절댓값과 관련된 정렬 필요
    절댓값의 최소값으로 정렬
3. 출력

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

public class Week3_BOJ11286 {    // 입출력 과정에서 발생하는 예외를 처리하여 프로그램의 안정성을 확보하기 위해 예외처리할 것
    public static void main (String[] args) throws IOException {
        // 들어오는 데이터 양이 많을 때는 BufferedReader를 사용하는 것이 좋다.
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine()); // 연산의 개수를 입력받음

        // 우선순위 큐를 이용하여 최소 힙을 구현
        PriorityQueue<Integer> myQueue = new PriorityQueue<>((a, b) -> {
            // 절댓값이 같은 경우에는 실제 값이 작은 순서대로
            int firstAbs = Math.abs(a);
            int secondAbs = Math.abs(b);

            if(firstAbs == secondAbs) {
                // a와 b의 절댓값이 같을 때, a와 b를 비교하여 작은 값을 우선순위로 함
                return a > b ? 1 : -1;
            }
            // 절댓값이 다를 경우에는 절댓값이 작은 순서대로 함
            return firstAbs - secondAbs;
        });

        // 연산을 처리하는 부분
        for(int i = 0; i < N; i++){
            int request = Integer.parseInt(br.readLine()); // 연산 입력을 받음

            if (request == 0) {
                // 연산이 0이면 최소 힙에서 값 꺼내서 출력
                if (myQueue.isEmpty()){
                    System.out.println("0");
                }else {
                    System.out.println(myQueue.poll());
                }
            } else {
                // 연산이 0이 아니면 최소 힙에 값을 추가
                myQueue.add(request);
            }
        }
    }
}
```

